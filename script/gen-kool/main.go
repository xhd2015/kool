package main

import (
	"fmt"
	"io/fs"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/xhd2015/less-gen/flags"
)

const help = `
gen-kool helps to generate kool commands

Usage: gen-kool [OPTIONS]

Options:
  -h,--help                        show help message
  -v,--verbose                     show verbose info
  --go-version <version>           generate specific Go version (e.g., 1.25, go1.25)
`

type TemplateData struct {
	GoVersion    string
	GoModVersion string
}

func main() {
	err := Handle(os.Args[1:])
	if err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

func Handle(args []string) error {
	var verbose bool
	var goVersionFlag string
	args, err := flags.
		Help("-h,--help", help).
		Bool("-v,--verbose", &verbose).
		String("--go-version", &goVersionFlag).
		Parse(args)
	if err != nil {
		return err
	}

	var goVersions []string

	if goVersionFlag != "" {
		// Normalize the version format
		normalizedVersion := normalizeGoVersion(goVersionFlag)
		if normalizedVersion == "" {
			return fmt.Errorf("invalid Go version format: %s (expected format: 1.25 or go1.25)", goVersionFlag)
		}
		goVersions = []string{normalizedVersion}
	} else {
		// Generate the default three kool-with-go modules
		goVersions = []string{"go1.18", "go1.19", "go1.24"}
	}

	for _, goVersion := range goVersions {
		if verbose {
			fmt.Printf("Generating kool-with-%s...\n", goVersion)
		}
		err := generateModule(goVersion, verbose)
		if err != nil {
			return fmt.Errorf("failed to generate kool-with-%s: %v", goVersion, err)
		}
	}

	if len(goVersions) == 1 {
		fmt.Printf("Successfully generated kool-with-%s module\n", goVersions[0])
	} else {
		fmt.Println("Successfully generated all kool-with-go modules")
	}
	return nil
}

// normalizeGoVersion converts various Go version formats to the standard "goX.Y" format
func normalizeGoVersion(version string) string {
	// Remove any whitespace
	version = strings.TrimSpace(version)

	// Handle "go1.25" format (already normalized)
	if strings.HasPrefix(version, "go") {
		return version
	}

	// Handle "1.25" format
	if strings.Contains(version, ".") {
		return "go" + version
	}

	// Invalid format
	return ""
}

// getGoModVersion returns the appropriate Go version requirement for go.mod based on the target Go version
func getGoModVersion(goVersion string) string {
	switch goVersion {
	case "go1.18", "go1.19":
		return "1.14"
	case "go1.24":
		return "1.18"
	default:
		// For newer versions, use a reasonable default
		return "1.18"
	}
}

// getGitTopLevel returns the git repository root directory
func getGitTopLevel() (string, error) {
	cmd := exec.Command("git", "rev-parse", "--show-toplevel")
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get git top-level directory: %v", err)
	}
	return strings.TrimSpace(string(output)), nil
}

func generateModule(goVersion string, verbose bool) error {
	// Get git top-level directory
	gitTopLevel, err := getGitTopLevel()
	if err != nil {
		return err
	}

	outputDir := filepath.Join(gitTopLevel, "cmd", "kool-with-"+goVersion)

	// Create output directory
	err = os.MkdirAll(outputDir, 0755)
	if err != nil {
		return fmt.Errorf("failed to create output directory %s: %v", outputDir, err)
	}

	templateData := TemplateData{
		GoVersion:    goVersion,
		GoModVersion: getGoModVersion(goVersion),
	}

	// Walk through template directory
	templateDir := filepath.Join(gitTopLevel, "script", "gen-kool", "kool-template")
	err = filepath.WalkDir(templateDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// Calculate relative path from template directory
		relPath, err := filepath.Rel(templateDir, path)
		if err != nil {
			return err
		}

		// Skip the root directory
		if relPath == "." {
			return nil
		}

		outputPath := filepath.Join(outputDir, relPath)

		if d.IsDir() {
			// Create directory
			return os.MkdirAll(outputPath, 0755)
		}

		// Process file
		if verbose {
			fmt.Printf("  Processing %s -> %s\n", path, outputPath)
		}

		// Read template file
		templateContent, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("failed to read template file %s: %v", path, err)
		}

		// Parse and execute template
		tmpl, err := template.New(filepath.Base(path)).Parse(string(templateContent))
		if err != nil {
			return fmt.Errorf("failed to parse template %s: %v", path, err)
		}

		// Create output file
		outputFile, err := os.Create(outputPath)
		if err != nil {
			return fmt.Errorf("failed to create output file %s: %v", outputPath, err)
		}
		defer outputFile.Close()

		// Add generated header for Go files
		if strings.HasSuffix(outputPath, ".go") {
			header := "// Code generated by script/gen-kool, DO NOT EDIT.\n\n"
			_, err = outputFile.WriteString(header)
			if err != nil {
				return fmt.Errorf("failed to write header to file %s: %v", outputPath, err)
			}
		}

		// Execute template
		err = tmpl.Execute(outputFile, templateData)
		if err != nil {
			return fmt.Errorf("failed to execute template %s: %v", path, err)
		}

		return nil
	})

	if err != nil {
		return err
	}

	// Copy the universal dlv.go file from tools/dlv/dlv.go
	if verbose {
		fmt.Printf("  Copying universal dlv.go file...\n")
	}
	err = copyUniversalDlvFile(outputDir)
	if err != nil {
		return fmt.Errorf("failed to copy dlv.go file: %v", err)
	}

	// Run go mod tidy using the appropriate Go version
	if verbose {
		fmt.Printf("  Running go mod tidy for %s...\n", goVersion)
	}

	cmd := exec.Command("kool", "with-go1.18", "go", "mod", "tidy")
	cmd.Dir = outputDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	err = cmd.Run()
	if err != nil {
		return fmt.Errorf("failed to run go mod tidy for %s: %v", goVersion, err)
	}

	return nil
}

// copyUniversalDlvFile copies the universal dlv.go file from tools/dlv/dlv.go to the output directory
func copyUniversalDlvFile(outputDir string) error {
	// Get git top-level directory
	gitTopLevel, err := getGitTopLevel()
	if err != nil {
		return err
	}

	// Source file path
	srcFile := filepath.Join(gitTopLevel, "tools", "dlv", "dlv.go")

	// Destination directory and file
	destDir := filepath.Join(outputDir, "dlv")
	destFile := filepath.Join(destDir, "dlv.go")

	// Create the dlv directory
	err = os.MkdirAll(destDir, 0755)
	if err != nil {
		return fmt.Errorf("failed to create dlv directory: %v", err)
	}

	// Read the source file
	srcContent, err := os.ReadFile(srcFile)
	if err != nil {
		return fmt.Errorf("failed to read source dlv.go file: %v", err)
	}

	// Add generated header and write to destination file
	header := "// Code generated by script/gen-kool, DO NOT EDIT.\n\n"
	finalContent := header + string(srcContent)

	err = os.WriteFile(destFile, []byte(finalContent), 0644)
	if err != nil {
		return fmt.Errorf("failed to write dlv.go file: %v", err)
	}

	return nil
}
